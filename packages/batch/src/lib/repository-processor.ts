import * as path from 'path';
import * as fs from 'fs/promises';
import * as os from 'os';
import { GitHubClient } from 'github-client';
import { ClaudeClient } from 'claude-client';
import { DynamoDBService } from './dynamodb-client';
import { JobStatus } from 'shared';

/**
 * Format conversation for storage
 * @param conversationHistory Conversation history
 * @returns Formatted conversation
 */
function formatConversationForStorage(conversationHistory: any[]): any {
  return {
    threadId: `thread-${Date.now()}`,
    messages: conversationHistory.map((message) => {
      // Convert user/assistant roles to human/assistant
      const role = message.role === 'user' ? 'human' : 'assistant';

      // Determine message type
      let type = 'prompt';
      if (role === 'assistant') {
        if (
          Array.isArray(message.content) &&
          message.content.some((block: any) => block.type === 'tool_use')
        ) {
          type = 'tool_call';
        } else {
          type = 'response';
        }
      } else if (
        Array.isArray(message.content) &&
        message.content.some((block: any) => block.type === 'tool_result')
      ) {
        type = 'tool_result';
      }

      return {
        role,
        content: message.content,
        timestamp: Date.now(),
        type,
      };
    }),
  };
}

/**
 * Determine if changes were necessary based on Claude's response
 * @param result Claude result
 * @returns Whether changes were necessary
 */
function determineIfChangesWereNecessary(result: any): boolean {
  // Check if any write_file tools were used
  const writeFileUsed = result.conversationHistory.some(
    (message: any) =>
      message.role === 'assistant' &&
      Array.isArray(message.content) &&
      message.content.some(
        (block: any) => block.type === 'tool_use' && block.name === 'write_file'
      )
  );

  // Check final message for indications of changes
  const finalMessages = result.conversationHistory.filter(
    (message: any) => message.role === 'assistant'
  );
  
  if (finalMessages.length === 0) {
    return false;
  }
  
  const finalMessage = finalMessages[finalMessages.length - 1];

  let finalText = '';
  if (Array.isArray(finalMessage.content)) {
    finalText = finalMessage.content
      .filter((block: any) => block.type === 'text')
      .map((block: any) => block.text)
      .join('\n');
  } else if (typeof finalMessage.content === 'string') {
    finalText = finalMessage.content;
  }

  const changeIndicators = [
    'made changes',
    'updated',
    'modified',
    'changed',
    'replaced',
  ];

  const textIndicatesChanges = changeIndicators.some((indicator) =>
    finalText.toLowerCase().includes(indicator)
  );

  return writeFileUsed || textIndicatesChanges;
}

/**
 * Generate pull request description
 * @param jobId Job ID
 * @param prompt Prompt
 * @param result Claude result
 * @returns Pull request description
 */
function generatePRDescription(
  jobId: string,
  prompt: string,
  result: any
): string {
  const finalMessages = result.conversationHistory.filter(
    (message: any) => message.role === 'assistant'
  );
  
  let finalText = '';
  if (finalMessages.length > 0) {
    const finalMessage = finalMessages[finalMessages.length - 1];
    if (Array.isArray(finalMessage.content)) {
      finalText = finalMessage.content
        .filter((block: any) => block.type === 'text')
        .map((block: any) => block.text)
        .join('\n');
    } else if (typeof finalMessage.content === 'string') {
      finalText = finalMessage.content;
    }
  }

  return `# Changes from Cody Batch

This pull request was automatically generated by Cody Batch (Job ID: ${jobId}).

## Prompt
${prompt}

## Claude's Summary
${finalText || 'No summary available'}

## Token Usage
- Input tokens: ${result.tokenUsage.input}
- Output tokens: ${result.tokenUsage.output}
- Total tokens: ${result.tokenUsage.input + result.tokenUsage.output}
`;
}

/**
 * Repository processor for handling individual repositories
 */
export class RepositoryProcessor {
  private githubClient: GitHubClient;
  private claudeClient: ClaudeClient;
  private dynamoDBService: DynamoDBService;

  /**
   * Create a new repository processor
   * @param githubClient GitHub client
   * @param claudeClient Claude client
   * @param dynamoDBService DynamoDB service
   */
  constructor(
    githubClient: GitHubClient,
    claudeClient: ClaudeClient,
    dynamoDBService: DynamoDBService
  ) {
    this.githubClient = githubClient;
    this.claudeClient = claudeClient;
    this.dynamoDBService = dynamoDBService;
  }

  /**
   * Process a repository
   * @param jobId Job ID
   * @param repositoryName Repository name
   * @param prompt Prompt
   * @param createPullRequests Whether to create pull requests
   * @returns Processing result
   */
  async processRepository(
    jobId: string,
    repositoryName: string,
    prompt: string,
    createPullRequests: boolean
  ): Promise<{
    wereChangesNecessary: boolean;
    pullRequestUrl?: string;
  }> {
    console.log(`Processing repository ${repositoryName} for job ${jobId}`);

    // Update repository status to processing
    await this.dynamoDBService.updateRepositoryStatus(
      jobId,
      repositoryName,
      JobStatus.PROCESSING,
      {
        startedAt: new Date().toISOString(),
      }
    );

    // Variable to store repository directory path
    let repoDir = '';
    
    try {
      // Clone repository
      // The GitHub client expects just the owner/repo format, not the full github.com URL
      // If the repository name starts with "github.com/", remove it
      const cleanRepoName = repositoryName.startsWith('github.com/')
        ? repositoryName.substring('github.com/'.length)
        : repositoryName;
      
      // Use the clean repository name (no correction needed as the typo is part of the actual repository name)
      console.log(`Cloning repository ${repositoryName} (using: ${cleanRepoName})`);
      const { git, repoPath } = await this.githubClient.cloneRepository(cleanRepoName);
      
      // Use the path returned by the GitHub client
      repoDir = repoPath;
      console.log(`Repository cloned to ${repoDir}`);

      // We're not creating branches or pull requests for now
      console.log(`Skipping branch creation - pull requests are disabled`);
      let branchName = '';

      // Run Claude analysis
      console.log(`Running Claude analysis on ${repositoryName}`);
      const result = await this.claudeClient.runAutonomousSession(
        repoDir,
        `Repository: ${repositoryName}\n\n${prompt}`,
        25 // Max iterations - increased from 10 to 25 for more thorough analysis
      );

      console.log(`Claude analysis completed for ${repositoryName}`);

      // Format conversation for storage
      const formattedConversation = formatConversationForStorage(
        result.conversationHistory
      );

      // Store Claude conversation
      await this.dynamoDBService.storeClaudeConversation(
        jobId,
        repositoryName,
        formattedConversation,
        {
          input: result.tokenUsage.input,
          output: result.tokenUsage.output,
          cacheCreation: result.tokenUsage.cacheCreation,
          cacheRead: result.tokenUsage.cacheRead,
          total: result.tokenUsage.input + result.tokenUsage.output,
        }
      );

      // Determine if changes were necessary
      const wereChangesNecessary = determineIfChangesWereNecessary(result);

      // Generate diff
      let diff = '';
      let pullRequestUrl: string | undefined;

      if (wereChangesNecessary) {
        console.log(`Changes were necessary for ${repositoryName}`);

        // Stage all changes to generate a proper diff
        console.log(`Staging changes for ${repositoryName} to generate diff`);
        await git.add('.');
        
        // Generate diff of staged changes
        console.log(`Generating diff for ${repositoryName}`);
        const diffResult = await git.diff(['--cached']);
        diff = diffResult || '';
        
        if (!diff) {
          console.log(`No diff generated for ${repositoryName}, checking for unstaged changes`);
          // Try to get unstaged changes if no staged changes were found
          const unstagedDiff = await git.diff();
          diff = unstagedDiff || '';
        }

        // Store diff
        await this.dynamoDBService.storeRepositoryDiff(
          jobId,
          repositoryName,
          diff
        );

        // Skip pull request creation - just store the diff
        console.log(`Skipping pull request creation - pull requests are disabled`);
        console.log(`Storing diff for ${repositoryName}`);
        
        // Log the diff for debugging
        console.log(`Diff for ${repositoryName}:`);
        console.log(diff.substring(0, 500) + (diff.length > 500 ? '... (truncated)' : ''));
        
        // Store the diff without creating a pull request
        await this.dynamoDBService.storeRepositoryDiff(
          jobId,
          repositoryName,
          diff
        );
      } else {
        console.log(`No changes were necessary for ${repositoryName}`);
      }

      // Update repository status to completed
      console.log(`Updating repository status to COMPLETED for ${repositoryName}`);
      const completedAt = new Date().toISOString();
      await this.dynamoDBService.updateRepositoryStatus(
        jobId,
        repositoryName,
        JobStatus.COMPLETED,
        {
          completedAt,
          wereChangesNecessary,
          // No pull request URL since we're not creating pull requests
          pullRequestUrl: null,
        }
      );
      console.log(`Repository status updated to COMPLETED at ${completedAt}`);

      return {
        wereChangesNecessary,
        // No pull request URL since we're not creating pull requests
        pullRequestUrl: null,
      };
    } catch (error) {
      console.error(`Error processing repository ${repositoryName}:`, error);

      // Update repository status to failed
      console.log(`Updating repository status to FAILED for ${repositoryName}`);
      const completedAt = new Date().toISOString();
      await this.dynamoDBService.updateRepositoryStatus(
        jobId,
        repositoryName,
        JobStatus.FAILED,
        {
          completedAt,
          error: error instanceof Error ? error.message : String(error),
          // No pull request URL since we're not creating pull requests
          pullRequestUrl: null,
        }
      );
      console.log(`Repository status updated to FAILED at ${completedAt}`);

      throw error;
    } finally {
      // Clean up repository directory
      console.log(`Cleaning up repository directory for ${repositoryName}...`);
      try {
        await fs.rm(repoDir, { recursive: true, force: true });
        console.log(`Repository directory ${repoDir} cleaned up successfully`);
      } catch (error) {
        console.error(`Error cleaning up repository directory ${repoDir}:`, error);
        console.error('Cleanup error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
      }
      console.log(`Repository processing completed for ${repositoryName} at ${new Date().toISOString()}`);
    }
  }
}