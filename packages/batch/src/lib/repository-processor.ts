import * as path from 'path';
import * as fs from 'fs/promises';
import * as os from 'os';
import { GitHubClient } from 'github-client';
import { ClaudeClient } from 'claude-client';
import { DynamoDBService } from './dynamodb-client';
import { JobStatus } from 'shared';

/**
 * Format conversation for storage
 * @param conversationHistory Conversation history
 * @returns Formatted conversation
 */
function formatConversationForStorage(conversationHistory: any[]): any {
  return {
    threadId: `thread-${Date.now()}`,
    messages: conversationHistory.map((message) => {
      // Convert user/assistant roles to human/assistant
      const role = message.role === 'user' ? 'human' : 'assistant';

      // Determine message type
      let type = 'prompt';
      if (role === 'assistant') {
        if (
          Array.isArray(message.content) &&
          message.content.some((block: any) => block.type === 'tool_use')
        ) {
          type = 'tool_call';
        } else {
          type = 'response';
        }
      } else if (
        Array.isArray(message.content) &&
        message.content.some((block: any) => block.type === 'tool_result')
      ) {
        type = 'tool_result';
      }

      return {
        role,
        content: message.content,
        timestamp: Date.now(),
        type,
      };
    }),
  };
}

/**
 * Determine if changes were necessary based on Claude's response
 * @param result Claude result
 * @returns Whether changes were necessary
 */
function determineIfChangesWereNecessary(result: any): boolean {
  // Check if any write_file tools were used
  const writeFileUsed = result.conversationHistory.some(
    (message: any) =>
      message.role === 'assistant' &&
      Array.isArray(message.content) &&
      message.content.some(
        (block: any) => block.type === 'tool_use' && block.name === 'write_file'
      )
  );

  // Check final message for indications of changes
  const finalMessages = result.conversationHistory.filter(
    (message: any) => message.role === 'assistant'
  );
  
  if (finalMessages.length === 0) {
    return false;
  }
  
  const finalMessage = finalMessages[finalMessages.length - 1];

  let finalText = '';
  if (Array.isArray(finalMessage.content)) {
    finalText = finalMessage.content
      .filter((block: any) => block.type === 'text')
      .map((block: any) => block.text)
      .join('\n');
  } else if (typeof finalMessage.content === 'string') {
    finalText = finalMessage.content;
  }

  const changeIndicators = [
    'made changes',
    'updated',
    'modified',
    'changed',
    'replaced',
  ];

  const textIndicatesChanges = changeIndicators.some((indicator) =>
    finalText.toLowerCase().includes(indicator)
  );

  return writeFileUsed || textIndicatesChanges;
}

/**
 * Generate pull request description
 * @param jobId Job ID
 * @param prompt Prompt
 * @param result Claude result
 * @returns Pull request description
 */
function generatePRDescription(
  jobId: string,
  prompt: string,
  result: any
): string {
  const finalMessages = result.conversationHistory.filter(
    (message: any) => message.role === 'assistant'
  );
  
  let finalText = '';
  if (finalMessages.length > 0) {
    const finalMessage = finalMessages[finalMessages.length - 1];
    if (Array.isArray(finalMessage.content)) {
      finalText = finalMessage.content
        .filter((block: any) => block.type === 'text')
        .map((block: any) => block.text)
        .join('\n');
    } else if (typeof finalMessage.content === 'string') {
      finalText = finalMessage.content;
    }
  }

  return `# Changes from Cody Batch

This pull request was automatically generated by Cody Batch (Job ID: ${jobId}).

## Prompt
${prompt}

## Claude's Summary
${finalText || 'No summary available'}

## Token Usage
- Input tokens: ${result.tokenUsage.input}
- Output tokens: ${result.tokenUsage.output}
- Total tokens: ${result.tokenUsage.input + result.tokenUsage.output}
`;
}

/**
 * Repository processor for handling individual repositories
 */
export class RepositoryProcessor {
  private githubClient: GitHubClient;
  private claudeClient: ClaudeClient;
  private dynamoDBService: DynamoDBService;

  /**
   * Create a new repository processor
   * @param githubClient GitHub client
   * @param claudeClient Claude client
   * @param dynamoDBService DynamoDB service
   */
  constructor(
    githubClient: GitHubClient,
    claudeClient: ClaudeClient,
    dynamoDBService: DynamoDBService
  ) {
    this.githubClient = githubClient;
    this.claudeClient = claudeClient;
    this.dynamoDBService = dynamoDBService;
  }

  /**
   * Process a repository
   * @param jobId Job ID
   * @param repositoryName Repository name
   * @param prompt Prompt
   * @param createPullRequests Whether to create pull requests
   * @returns Processing result
   */
  async processRepository(
    jobId: string,
    repositoryName: string,
    prompt: string,
    createPullRequests: boolean
  ): Promise<{
    wereChangesNecessary: boolean;
    pullRequestUrl?: string;
  }> {
    console.log(`Processing repository ${repositoryName} for job ${jobId}`);

    // Update repository status to processing
    await this.dynamoDBService.updateRepositoryStatus(
      jobId,
      repositoryName,
      JobStatus.PROCESSING,
      {
        startedAt: new Date().toISOString(),
      }
    );

    // Create temporary directory for repository
    const repoDir = path.join(
      os.tmpdir(),
      `cody-batch-${jobId}-${repositoryName.replace('/', '-')}`
    );

    try {
      // Clone repository
      console.log(`Cloning repository ${repositoryName} to ${repoDir}`);
      const { git } = await this.githubClient.cloneRepository(repositoryName);

      // Create branch if creating pull requests
      let branchName = '';
      if (createPullRequests) {
        branchName = `cody-batch/${jobId}`;
        console.log(`Creating branch ${branchName}`);
        await git.checkoutBranch(branchName, 'main');
      }

      // Run Claude analysis
      console.log(`Running Claude analysis on ${repositoryName}`);
      const result = await this.claudeClient.runAutonomousSession(
        repoDir,
        `Repository: ${repositoryName}\n\n${prompt}`,
        10 // Max iterations
      );

      console.log(`Claude analysis completed for ${repositoryName}`);

      // Format conversation for storage
      const formattedConversation = formatConversationForStorage(
        result.conversationHistory
      );

      // Store Claude conversation
      await this.dynamoDBService.storeClaudeConversation(
        jobId,
        repositoryName,
        formattedConversation,
        {
          input: result.tokenUsage.input,
          output: result.tokenUsage.output,
          cacheCreation: result.tokenUsage.cacheCreation,
          cacheRead: result.tokenUsage.cacheRead,
          total: result.tokenUsage.input + result.tokenUsage.output,
        }
      );

      // Determine if changes were necessary
      const wereChangesNecessary = determineIfChangesWereNecessary(result);

      // Generate diff
      let diff = '';
      let pullRequestUrl: string | undefined;

      if (wereChangesNecessary) {
        console.log(`Changes were necessary for ${repositoryName}`);

        // Generate diff
        const diffResult = await git.diff(['--cached']);
        diff = diffResult || '';

        // Store diff
        await this.dynamoDBService.storeRepositoryDiff(
          jobId,
          repositoryName,
          diff
        );

        // Create pull request if requested
        if (createPullRequests && branchName) {
          console.log(`Creating pull request for ${repositoryName}`);

          // Commit changes
          await git.add('.');
          await git.commit(`Changes from Cody Batch (Job ID: ${jobId})`);

          // Push branch
          await git.push('origin', branchName);

          // Create pull request
          const [owner, repo] = repositoryName.split('/');
          const pr = await this.githubClient.createPullRequest(
            repositoryName,
            `Cody Batch: ${jobId}`,
            generatePRDescription(jobId, prompt, result),
            branchName,
            'main'
          );

          pullRequestUrl = pr.htmlUrl;

          // Store pull request URL
          await this.dynamoDBService.storeRepositoryDiff(
            jobId,
            repositoryName,
            diff,
            pullRequestUrl
          );
        }
      } else {
        console.log(`No changes were necessary for ${repositoryName}`);
      }

      // Update repository status to completed
      await this.dynamoDBService.updateRepositoryStatus(
        jobId,
        repositoryName,
        JobStatus.COMPLETED,
        {
          completedAt: new Date().toISOString(),
          wereChangesNecessary,
          pullRequestUrl,
        }
      );

      return {
        wereChangesNecessary,
        pullRequestUrl,
      };
    } catch (error) {
      console.error(`Error processing repository ${repositoryName}:`, error);

      // Update repository status to failed
      await this.dynamoDBService.updateRepositoryStatus(
        jobId,
        repositoryName,
        JobStatus.FAILED,
        {
          completedAt: new Date().toISOString(),
          error: error instanceof Error ? error.message : String(error),
        }
      );

      throw error;
    } finally {
      // Clean up repository directory
      try {
        await fs.rm(repoDir, { recursive: true, force: true });
      } catch (error) {
        console.error(`Error cleaning up repository directory ${repoDir}:`, error);
      }
    }
  }
}